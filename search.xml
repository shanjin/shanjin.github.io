<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode-072-Edit-Distance</title>
      <link href="/2019/03/04/leetcode-072-Edit-Distance/"/>
      <url>/2019/03/04/leetcode-072-Edit-Distance/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:</p><p>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2:</p><p>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minDistance(self, word1, word2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type word1: str</span><br><span class="line">        :type word2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 动态规划，从word1和word2的第一个字符开始</span><br><span class="line">        </span><br><span class="line">        m = len(word1)</span><br><span class="line">        n = len(word2)</span><br><span class="line">        </span><br><span class="line">        # 如果word1是空串，则word1需要 增加 n个字符转换为word2</span><br><span class="line">        if m == 0:</span><br><span class="line">            return n</span><br><span class="line">        </span><br><span class="line">        # 如果word2是空串，则word1需要 删除 m个字符串转换为word2</span><br><span class="line">        if n == 0:</span><br><span class="line">            return m</span><br><span class="line">        </span><br><span class="line">        # 初始化dp和边界</span><br><span class="line">        dp = [[0]*(n+1) for _ in range(m+1)]</span><br><span class="line">        for i in range(1,m+1):</span><br><span class="line">            dp[i][0] = i</span><br><span class="line">        for j in range(1,n+1):</span><br><span class="line">            dp[0][j] = j</span><br><span class="line">        </span><br><span class="line">        for i in range(1,m+1):</span><br><span class="line">            for j in range(1,n+1):</span><br><span class="line">                if word1[i-1] == word2[j-1]:</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] = min(dp[i-1][j-1]+1,</span><br><span class="line">                                   dp[i][j-1]+1,</span><br><span class="line">                                   dp[i-1][j]+1</span><br><span class="line">                                  )</span><br><span class="line">        return dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-208-Implement-Trie-Prefix-Tree</title>
      <link href="/2019/03/04/leetcode-208-Implement-Trie-Prefix-Tree/"/>
      <url>/2019/03/04/leetcode-208-Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:</p><p>Trie trie = new Trie();</p><p>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true<br>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Trie(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end = -1</span><br><span class="line"></span><br><span class="line">    def insert(self, word):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Inserts a word into the trie.</span><br><span class="line">        :type word: str</span><br><span class="line">        :rtype: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node = self.root</span><br><span class="line">        for c in word:</span><br><span class="line">            if c not in node:</span><br><span class="line">                node[c] = &#123;&#125;</span><br><span class="line">            node = node[c]</span><br><span class="line">        node[self.end] = True</span><br><span class="line">        return self.root</span><br><span class="line"></span><br><span class="line">    def search(self, word):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns if the word is in the trie.</span><br><span class="line">        :type word: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node = self.root</span><br><span class="line">        for c in word:</span><br><span class="line">            if c not in node:</span><br><span class="line">                return False</span><br><span class="line">            node = node[c]</span><br><span class="line">        return self.end in node</span><br><span class="line"></span><br><span class="line">    def startsWith(self, prefix):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns if there is any word in the trie that starts with the given prefix.</span><br><span class="line">        :type prefix: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node = self.root</span><br><span class="line">        for c in prefix:</span><br><span class="line">            if c not in node:</span><br><span class="line">                return False</span><br><span class="line">            node = node[c]</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Your Trie object will be instantiated and called as such:</span><br><span class="line"># obj = Trie()</span><br><span class="line"># obj.insert(word)</span><br><span class="line"># param_2 = obj.search(word)</span><br><span class="line"># param_3 = obj.startsWith(prefix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-069-Sqrt_x</title>
      <link href="/2019/03/04/leetcode-069-Sqrt-x/"/>
      <url>/2019/03/04/leetcode-069-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def mySqrt(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if x &lt; 2:</span><br><span class="line">            return x</span><br><span class="line">        left = 0</span><br><span class="line">        right = x</span><br><span class="line">        while left &lt;= right:</span><br><span class="line">            mid = left + (right - left) / 2</span><br><span class="line">            if mid * mid &lt;= x &lt; (mid+1)*(mid+1):</span><br><span class="line">                return mid</span><br><span class="line">            elif mid*mid &lt; x:</span><br><span class="line">                left = mid + 1</span><br><span class="line">            else:</span><br><span class="line">                right = mid - 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-111-Minimum-Depth-of-Binary-Tree</title>
      <link href="/2019/03/04/leetcode-111-Minimum-Depth-of-Binary-Tree/"/>
      <url>/2019/03/04/leetcode-111-Minimum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最小深度  2.</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        if not root.left:</span><br><span class="line">            return 1+self.minDepth(root.right)</span><br><span class="line">        elif not root.right:</span><br><span class="line">            return 1+self.minDepth(root.left)</span><br><span class="line">        else:</span><br><span class="line">            return 1+min(self.minDepth(root.left),self.minDepth(root.right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        nodes = [root]</span><br><span class="line">        min_depth = 0</span><br><span class="line">        while nodes:</span><br><span class="line">            min_depth += 1</span><br><span class="line">            new_nodes = []</span><br><span class="line">            for node in nodes:</span><br><span class="line">                if node.left:</span><br><span class="line">                    new_nodes.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    new_nodes.append(node.right)</span><br><span class="line">                if not node.left and not node.right:</span><br><span class="line">                    return min_depth</span><br><span class="line">            nodes = new_nodes</span><br><span class="line">        return min_depth</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-104-Maximum-Depth-of-Binary-Tree</title>
      <link href="/2019/03/04/leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2019/03/04/leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        max_layer = 0</span><br><span class="line">        nodes = [root]</span><br><span class="line">        while nodes:</span><br><span class="line">            new_nodes = []</span><br><span class="line">            max_layer += 1</span><br><span class="line">            for node in nodes:</span><br><span class="line">                if node.left:</span><br><span class="line">                    new_nodes.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    new_nodes.append(node.right)</span><br><span class="line">            nodes = new_nodes</span><br><span class="line">        return max_layer</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-102-Binary-Tree-Level-Order-Traversal</title>
      <link href="/2019/03/04/leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2019/03/04/leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def levelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # DFS 深度优先搜索</span><br><span class="line">        </span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        # res是一个二维数组</span><br><span class="line">        self.res = []</span><br><span class="line">        self._dfs(root,0)</span><br><span class="line">        return self.res</span><br><span class="line">    </span><br><span class="line">    def _dfs(self,node,layer):</span><br><span class="line">        # 给当前层分配[]，接下来将节点的值存在当前层的list中</span><br><span class="line">        if len(self.res) &lt; layer + 1:</span><br><span class="line">            self.res.append([])</span><br><span class="line">        self.res[layer].append(node.val)</span><br><span class="line">        if node.left:</span><br><span class="line">            self._dfs(node.left,layer+1)</span><br><span class="line">        if node.right:</span><br><span class="line">            self._dfs(node.right,layer+1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def levelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # BFS 广度优先搜索</span><br><span class="line">        # 从上到下，每一层的节点进入队列</span><br><span class="line">        </span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        nodes = [root]</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        while nodes:</span><br><span class="line">            next_nodes = []</span><br><span class="line">            sub_res = []</span><br><span class="line">            for node in nodes:</span><br><span class="line">                sub_res.append(node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    next_nodes.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    next_nodes.append(node.right)</span><br><span class="line">            res.append(sub_res)</span><br><span class="line">            nodes = next_nodes</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree</title>
      <link href="/2019/03/04/leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
      <url>/2019/03/04/leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 二叉搜索树前序遍历是递增的有序数组</span><br><span class="line">        </span><br><span class="line">        # 参数判断</span><br><span class="line">        if root == None or root == q or root == p:</span><br><span class="line">            return root</span><br><span class="line">        </span><br><span class="line">        # 如果根节点大于p和q的话，则p和q应该在左子树中，且最近公共祖先也在左子树中</span><br><span class="line">        elif p.val &lt; root.val and q.val &lt; root.val:</span><br><span class="line">            return self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        </span><br><span class="line">        # 如果根节点小于p和q的话，则p和q应该在右子树中，且最近公共祖先也在右子树中</span><br><span class="line">        elif p.val &gt; root.val and q.val &gt; root.val:</span><br><span class="line">            return self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        </span><br><span class="line">        # 如果根节点大于p，且小于q，则为最近公共祖先</span><br><span class="line">        else:</span><br><span class="line">            return root </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while root:</span><br><span class="line">            if root.val &gt; q.val and root.val &gt; p.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            elif root.val &lt; q.val and root.val &lt; p.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            else:</span><br><span class="line">                return root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-120-Triangle</title>
      <link href="/2019/02/28/leetcode-120-Triangle/"/>
      <url>/2019/02/28/leetcode-120-Triangle/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>说明：</p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minimumTotal(self, triangle):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not triangle:</span><br><span class="line">            return 0</span><br><span class="line"># 动态规划：自底向上的递推</span><br><span class="line"># 初始化状态是三角形的倒数第一行</span><br><span class="line">        res = triangle[-1]</span><br><span class="line"># 从三角形的倒数第二行开始递推</span><br><span class="line"># 注意：Python的range函数是[)左闭右开的</span><br><span class="line">        for i in xrange(len(triangle)-2,-1,-1):</span><br><span class="line">            for j in xrange(len(triangle[i])):</span><br><span class="line">                res[j] = triangle[i][j] + min(res[j],res[j+1])</span><br><span class="line">        return res[0]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-070-Climbing-Stairs</title>
      <link href="/2019/02/28/leetcode-070-Climbing-Stairs/"/>
      <url>/2019/02/28/leetcode-070-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><p>类似斐波那契数列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def climbStairs(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if n == 0 or n == 1 or n ==2:</span><br><span class="line">            return n</span><br><span class="line">        a = 1</span><br><span class="line">        b = 2</span><br><span class="line">        while n &gt; 2:</span><br><span class="line">            res = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = res</span><br><span class="line">            n -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-050-Pow</title>
      <link href="/2019/02/28/leetcode-050-Pow/"/>
      <url>/2019/02/28/leetcode-050-Pow/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p>示例 1:</p><p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p><p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p><p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:</p><p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><p>递归解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myPow(self, x, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: float</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if n == 0:</span><br><span class="line">            return 1</span><br><span class="line">        if n &lt; 0:</span><br><span class="line">            return 1 / self.myPow(x,-n)</span><br><span class="line">        # 分治法</span><br><span class="line">        # 这是一个倒三角的计算过程</span><br><span class="line">        # 顶层为所有的x，两两相乘之后的结果下降一层，这时x的n次方就转换为(x*x)的n/2次方</span><br><span class="line">        # n分为奇数和偶数的情况</span><br><span class="line">        if n % 2 == 1:</span><br><span class="line">            return x * self.myPow(x,n-1)</span><br><span class="line">        else:</span><br><span class="line">            return self.myPow(x*x,n/2)</span><br></pre></td></tr></table></figure></p><p>非递归解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myPow(self, x, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: float</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        flag = 1</span><br><span class="line">        if n &lt; 0:</span><br><span class="line">            flag = 0</span><br><span class="line">            n = -n</span><br><span class="line">        res = 1</span><br><span class="line">        # 思路和递归的是一样的，用n次方作为循环的条件</span><br><span class="line">        # n为奇数时，n = n-1</span><br><span class="line">        # n为偶数时，n = n/2</span><br><span class="line">        # 不论初始的n是奇数还是偶数，最终都会停止在n=1上，</span><br><span class="line">        # 所以在所有满足n%2=1的时候，都用res去乘，res会记录最终的值</span><br><span class="line">        while n:</span><br><span class="line">            if n % 2 == 1:</span><br><span class="line">                res = res * x</span><br><span class="line">                n = n-1</span><br><span class="line">            else:</span><br><span class="line">                x = x*x</span><br><span class="line">                n = n/2</span><br><span class="line">        if flag == 1:</span><br><span class="line">            return res</span><br><span class="line">        else:</span><br><span class="line">            return 1 / res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-239-Sliding-Window-Maximun</title>
      <link href="/2019/02/23/leetcode-239-Sliding-Window-Maximun/"/>
      <url>/2019/02/23/leetcode-239-Sliding-Window-Maximun/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p>  滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>注意：</p><p>你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSlidingWindow(self, nums, k):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 滑窗使用双端队列(deque)数据结构，且只存下标</span><br><span class="line">        # 这个队列中，队首为最大元素的下标，之后的元素都比队首小</span><br><span class="line">        window = []</span><br><span class="line">        </span><br><span class="line">        # 存每一个滑窗中的最大值，最后返回</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        # 检验参数是否有非法情况</span><br><span class="line">        if k &gt; len(nums) or len(nums) == 0 or k == 0:</span><br><span class="line">            return res</span><br><span class="line">        </span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            </span><br><span class="line">            # step1：滑窗移动</span><br><span class="line">            </span><br><span class="line">            # 使用下标控制滑窗范围</span><br><span class="line">            # 滑窗移动一格，导致队首元素从滑窗离开，则从deque的头部出队</span><br><span class="line">            # 注意: 1 window存的是下标；</span><br><span class="line">            #       2 i为待进队的元素下标；</span><br><span class="line">            #       3 待进队元素，在满足所有逻辑判断条件之后，才进队</span><br><span class="line">            # i-k是window左界：0 window[1 2 3] 4,此时i=4,k=3</span><br><span class="line">            # window移动一格后为 0 1 window[2 3 4]，即window[0]出队，腾出空间给4进队</span><br><span class="line">            </span><br><span class="line">            if len(window) &gt; 0 and window[0] &lt;= i - k:</span><br><span class="line">                window.pop(0)</span><br><span class="line">                </span><br><span class="line">            # step2：维护deque</span><br><span class="line">            </span><br><span class="line">            # 只要deque中有比待入队元素小的值，则从队尾移除</span><br><span class="line">            # 即，deque中，只保存可能是最大值的下标</span><br><span class="line">            </span><br><span class="line">            while len(window) &gt; 0 and nums[i] &gt; nums[window[-1]]:</span><br><span class="line">                window.pop()</span><br><span class="line">                </span><br><span class="line">            # 满足逻辑判断之后，新元素下标入队</span><br><span class="line">            window.append(i)</span><br><span class="line">            </span><br><span class="line">            # 弹出滑窗中最大的元素</span><br><span class="line">            if i &gt;= k - 1:</span><br><span class="line">                res.append(nums[window[0]])</span><br><span class="line">        </span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def maxSlidingWindow(self, nums, k):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        if len(nums) == 0 or k == 0 or k &gt; len(nums):</span><br><span class="line">            return res</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if i+k &lt;= len(nums):</span><br><span class="line">                res.append(max(nums[i:i+k]))</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-242-Valid-Anagram</title>
      <link href="/2019/02/23/leetcode-242-Valid-Anagram/"/>
      <url>/2019/02/23/leetcode-242-Valid-Anagram/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</p><p>示例 1:</p><p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p><p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p><p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isAnagram(self, s, t):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # python中ord和chr的用法</span><br><span class="line">        # ord（）函数就是用来返回单个字符的ascii值（0-255）或者unicode数值（）</span><br><span class="line">        # ord(&apos;a&apos;) = 97</span><br><span class="line">        # chr（）函数是输入一个整数[0，255]返回其对应的ascii符号</span><br><span class="line">        # chr(97) = &apos;a&apos;</span><br><span class="line">        dic1 = [0]*26</span><br><span class="line">        dic2 = [0]*26</span><br><span class="line">        for i in s:</span><br><span class="line">            dic1[ord(i) - ord(&apos;a&apos;)] += 1</span><br><span class="line">        for j in t:</span><br><span class="line">            dic2[ord(j) - ord(&apos;a&apos;)] += 1</span><br><span class="line">        return dic1 == dic2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def isAnagram(self, s, t):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dict1 = &#123;&#125;</span><br><span class="line">        dict2 = &#123;&#125;</span><br><span class="line">        for i in s:</span><br><span class="line">            dict1[i] = dict1.get(i,0) + 1</span><br><span class="line">        for j in t:</span><br><span class="line">            dict2[j] = dict2.get(j,0) + 1</span><br><span class="line">        return dict1 == dict2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-703-Kth-Largest-Element-in-a-Stream</title>
      <link href="/2019/02/21/leetcode-703-Kth-Largest-Element-in-a-Stream/"/>
      <url>/2019/02/21/leetcode-703-Kth-Largest-Element-in-a-Stream/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p><p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p><p>示例:</p><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8<br>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><p>优先队列，即堆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class KthLargest(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, k, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type k: int</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line"># 将nums(list)就地转换为heap对象</span><br><span class="line">        heapq.heapify(self.nums)</span><br><span class="line"></span><br><span class="line"># 如果nums长度大于k，则只保留K个结点的堆，根节点就是第K个大的值</span><br><span class="line">        while len(self.nums) &gt; self.k:</span><br><span class="line">            heapq.heappop(self.nums)</span><br><span class="line">        </span><br><span class="line">    def add(self, val):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 如果nums长度小于k，则将val压入堆中</span><br><span class="line">        if self.k &gt; len(self.nums):</span><br><span class="line">            heapq.heappush(self.nums,val)</span><br><span class="line"></span><br><span class="line"># 否则nums长度大于k时，先将val压入堆，排序好之后，pop根节点</span><br><span class="line">        else:</span><br><span class="line">            heapq.heappushpop(self.nums,val)</span><br><span class="line">        return self.nums[0]</span><br><span class="line">            </span><br><span class="line"># Your KthLargest object will be instantiated and called as such:</span><br><span class="line"># obj = KthLargest(k, nums)</span><br><span class="line"># param_1 = obj.add(val)</span><br></pre></td></tr></table></figure></p><p>这里用到了堆数据结构（Heap）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将已知的 list 转化为 heap 对象，默认为小顶堆</span><br><span class="line">heapq.heapify(list)</span><br><span class="line"></span><br><span class="line"># 将 item 压入 heap</span><br><span class="line">heapq.heappush(heap,item)</span><br><span class="line"></span><br><span class="line"># 弹出 heap 中最小的值，即为树的根节点</span><br><span class="line">heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line"># 将 item 压入 heap，弹出最小值，并重新排序堆结构</span><br><span class="line">heapq.heappushpop(item)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-020-Valid-Parentheses</title>
      <link href="/2019/02/21/leetcode-020-Valid-Parentheses/"/>
      <url>/2019/02/21/leetcode-020-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isValid(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        stack = []</span><br><span class="line"># 这里用字典的设计很巧妙</span><br><span class="line">        paren_map = &#123;&apos;)&apos;:&apos;(&apos;, &apos;]&apos;:&apos;[&apos;, &apos;&#125;&apos;:&apos;&#123;&apos;&#125;</span><br><span class="line">        for c in s:</span><br><span class="line">            </span><br><span class="line">            # 如果不是右括号（是左括号），则此括号入栈</span><br><span class="line">            if c not in paren_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                </span><br><span class="line">            # 来到这里说明是右括号，这时有两种情况：</span><br><span class="line">            # 1.栈空：此右括号之前的字符串都可以匹配，此时栈空，右括号入栈，false</span><br><span class="line">            # 2.栈不空：此右括号与栈顶的左括号不匹配</span><br><span class="line">            elif not stack or paren_map[c] != stack.pop():</span><br><span class="line">                return False</span><br><span class="line">            </span><br><span class="line">        # 如果遍历结束，字符串末端有多余的左括号，没有右括号与之匹配</span><br><span class="line">        # 此时栈中存的都是左括号，false</span><br><span class="line">        return not stack</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-025-Reverse-Nodes-in-k-Group</title>
      <link href="/2019/02/11/leetcode-025-Reverse-Nodes-in-k-Group/"/>
      <url>/2019/02/11/leetcode-025-Reverse-Nodes-in-k-Group/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p><p>示例 :<br>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明 :<br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def reverseKGroup(self, head, k):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"># k=1时为原链表</span><br><span class="line">        if k == 1:</span><br><span class="line">            return head</span><br><span class="line">        </span><br><span class="line"># c遍历链表，为当前结点</span><br><span class="line">        c = head</span><br><span class="line"></span><br><span class="line"># 用tot算出总节点数，知道什么时候该停止</span><br><span class="line">        tot = 0</span><br><span class="line">        p = head</span><br><span class="line">        while p:</span><br><span class="line">            p = p.next</span><br><span class="line">            tot += 1</span><br><span class="line">            </span><br><span class="line"># cnt表示目前为止一共reverse了几个节点</span><br><span class="line">        cnt = 0</span><br><span class="line"></span><br><span class="line">#从头部开始遍历</span><br><span class="line">        while c:</span><br><span class="line"></span><br><span class="line">#判断翻转K个是否越界</span><br><span class="line">            if cnt + k &lt;= tot:</span><br><span class="line"></span><br><span class="line">#分情况讨论，如果是第一次reverse，那么直接返回原始链表的head</span><br><span class="line">                if cnt == 0:</span><br><span class="line"># 这里需要注意的是，第一次反转，记得使用原始链表的头结点head</span><br><span class="line">                    head = self.reverse(c,k)</span><br><span class="line">                    cnt += k</span><br><span class="line">                else:</span><br><span class="line"># 如果不是第一次反转</span><br><span class="line"># 这里有个巧妙的地方，当我们进行完第一次后，c指向第一个reverse区间的最后一个节点</span><br><span class="line"># 所以需要反转c.next为头的子链表</span><br><span class="line"># 这里用临时的头结点head_k替代c遍历链表</span><br><span class="line">                    head_k = c.next</span><br><span class="line"># 用临时的新头结点指向反转好的子链表</span><br><span class="line">                    new_head = self.reverse(head_k,k)</span><br><span class="line">                    cnt += k</span><br><span class="line"># 将之前的链表和反转好的子链表接起来</span><br><span class="line">                    c.next = new_head</span><br><span class="line"># 反转结束后，临时的头结点head_k指向子链表的末尾，重置c的位置</span><br><span class="line">                    c = head_k</span><br><span class="line"></span><br><span class="line">#越界就说明我们已经reverse了能reverse的部分，直接退出</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return head</span><br><span class="line">    </span><br><span class="line"># 206反转链表（代码思路一模一样）</span><br><span class="line"># 需要注意的是，N个结点的需要反转N-1次</span><br><span class="line">    def reverse(self,head_k,k):</span><br><span class="line">#记录目前reverse的数量</span><br><span class="line">        count = 1</span><br><span class="line">        new_head = head_k</span><br><span class="line">        while count &lt; k:</span><br><span class="line">            t = head_k.next</span><br><span class="line">            head_k.next = head_k.next.next</span><br><span class="line">            t.next = new_head</span><br><span class="line">            new_head = t</span><br><span class="line">            count += 1</span><br><span class="line">        return new_head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-141-Linked-List-Cycle</title>
      <link href="/2019/02/11/leetcode-141-Linked-List-Cycle/"/>
      <url>/2019/02/11/leetcode-141-Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-141-Linked-List-Cycle-环形链表"><a href="#leetcode-141-Linked-List-Cycle-环形链表" class="headerlink" title="leetcode-141-Linked-List-Cycle 环形链表"></a>leetcode-141-Linked-List-Cycle 环形链表</h1><hr><p>环形链表两个点：</p><ol><li>循环次数 = 环的长度：快慢指针一直到相遇时的循环次数等于环的长度</li><li>相遇点到环入口点的距离 = 链表起始点到环入口点的距离</li></ol><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><p>快慢指针。<a href="https://www.jianshu.com/p/1c59b153308c" target="_blank" rel="noopener">参考这里</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        while fast and slow and fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            if fast is slow:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p><hr><h2 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p><p>进阶：<br>你是否可以不用额外空间解决此题？</p><h2 id="2-解-1"><a href="#2-解-1" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode(object):</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def detectCycle(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        fast = slow = head</span><br><span class="line">        while slow and fast and fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            if fast is slow:</span><br><span class="line">                new_head = head</span><br><span class="line">                while new_head is not slow:</span><br><span class="line">                    new_head = new_head.next</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                return new_head</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-024-Swap-Nodes-in-Pairs</title>
      <link href="/2019/02/10/leetcode-024-Swap-Nodes-in-Pairs/"/>
      <url>/2019/02/10/leetcode-024-Swap-Nodes-in-Pairs/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-024-Swap-Nodes-in-Pairs-两两交换链表中的节点"><a href="#leetcode-024-Swap-Nodes-in-Pairs-两两交换链表中的节点" class="headerlink" title="leetcode-024-Swap-Nodes-in-Pairs 两两交换链表中的节点"></a>leetcode-024-Swap-Nodes-in-Pairs 两两交换链表中的节点</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2.解"></a>2.解</h2><p>四个需要注意的点吧：</p><ol><li>给三个指针，分别指向两个待交换结点和他们的前驱结点</li><li>链表的两个特殊情况：[] and [1]</li><li>链表的两两交换结点操作</li><li>重置三个指针的位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 开一个常数空间的头结点</span><br><span class="line">        new_head = ListNode(-1)</span><br><span class="line"># pre始终指向待交换结点的前驱结点</span><br><span class="line">        pre = new_head</span><br><span class="line">        first = head</span><br><span class="line">        </span><br><span class="line"># 两种特殊情况：[] and [1]</span><br><span class="line">        if head == None or head.next == None:</span><br><span class="line">            return head</span><br><span class="line">        else:   </span><br><span class="line">            second = head.next</span><br><span class="line"></span><br><span class="line">        while second:</span><br><span class="line"></span><br><span class="line">            # 两两交换结点的经典操作</span><br><span class="line">            pre.next = second</span><br><span class="line">            first.next = second.next</span><br><span class="line">            second.next = first</span><br><span class="line">            </span><br><span class="line"># 重置三个结点</span><br><span class="line">            pre = first</span><br><span class="line">            first = pre.next</span><br><span class="line">            second = pre.next.next if first else None</span><br><span class="line">        return new_head.next</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-206-Reverse-Linked-List</title>
      <link href="/2019/02/03/leetcode-206-Reverse-Linked-List/"/>
      <url>/2019/02/03/leetcode-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-206-Reverse-Linked-List-反转链表"><a href="#leetcode-206-Reverse-Linked-List-反转链表" class="headerlink" title="leetcode-206-Reverse-Linked-List 反转链表"></a>leetcode-206-Reverse-Linked-List 反转链表</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><h3 id="2-1-方法一：借用栈结构反转"><a href="#2-1-方法一：借用栈结构反转" class="headerlink" title="2.1 方法一：借用栈结构反转"></a>2.1 方法一：借用栈结构反转</h3><p>借用Python中list中的insert()函数实现栈结构，用栈来反转。<br>需要注意的是：整个过程中，不动head结点，新初始化一个结点p来遍历链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        p = head</span><br><span class="line">        newList = []</span><br><span class="line">        while p:</span><br><span class="line">            newList.insert(0,p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        p = head</span><br><span class="line">        for x in newList:</span><br><span class="line">            p.val = x</span><br><span class="line">            p = p.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure></p><h3 id="2-2-方法二：迭代反转"><a href="#2-2-方法二：迭代反转" class="headerlink" title="2.2 方法二：迭代反转"></a>2.2 方法二：迭代反转</h3><p>其实就是头插法。</p><h4 id="2-2-1-头插法一："><a href="#2-2-1-头插法一：" class="headerlink" title="2.2.1 头插法一："></a>2.2.1 头插法一：</h4><p>在链表中反转（head的后继结点插入链表头）<br>head遍历链表。t为head的后继结点，反转操作主要是：<br>head指向head.next.next（即为t.next，把t摘下来），t插入链表头（t.next = new_head），重置头结点（new_head = t）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;      </span><br><span class="line">        if head is None:</span><br><span class="line">            return head</span><br><span class="line"># new_head保存链表头，head遍历链表</span><br><span class="line">        new_head = head</span><br><span class="line">        </span><br><span class="line">        while head.next is not None:</span><br><span class="line">            t = head.next</span><br><span class="line">            head.next = head.next.next</span><br><span class="line">            t.next = new_head</span><br><span class="line">            new_head = t</span><br><span class="line">        return new_head</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-头插法二："><a href="#2-2-2-头插法二：" class="headerlink" title="2.2.2 头插法二："></a>2.2.2 头插法二：</h4><p>链表拆分为两条（head的前序结点插入链表头）<br>head遍历链表，p为head的前序结点，反转操作主要是：<br>将前序结点p直接插在新链表new_head之前（p.next = new_head），重新将new_head指向头结点（new_head = p）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        new_head = None</span><br><span class="line">        while head:</span><br><span class="line"># 前序结点</span><br><span class="line">            p = head</span><br><span class="line"># 当前结点</span><br><span class="line">            head = head.next</span><br><span class="line"># 将前序结点插入新链表new_head之前</span><br><span class="line">            p.next = new_head</span><br><span class="line"># 新链表头指针归位</span><br><span class="line">            new_head = p</span><br><span class="line">        return new_head</span><br></pre></td></tr></table></figure></p><h3 id="2-3-方法三：递归"><a href="#2-3-方法三：递归" class="headerlink" title="2.3 方法三：递归"></a>2.3 方法三：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        p = head.next</span><br><span class="line">        n = self.reverseList(p)</span><br><span class="line"></span><br><span class="line">        head.next = None</span><br><span class="line">        p.next = head</span><br><span class="line">        return n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-016-3Sum-Closest</title>
      <link href="/2019/02/01/leetcode-016-3Sum-Closest/"/>
      <url>/2019/02/01/leetcode-016-3Sum-Closest/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-016-3Sum-Closest-最接近的三数之和"><a href="#leetcode-016-3Sum-Closest-最接近的三数之和" class="headerlink" title="leetcode-016-3Sum-Closest 最接近的三数之和"></a>leetcode-016-3Sum-Closest 最接近的三数之和</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = sum(nums[:3])</span><br><span class="line">        m = abs(res - target)</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            l = i+1</span><br><span class="line">            r = len(nums)-1</span><br><span class="line">            while l &lt; r:</span><br><span class="line">                temp = nums[i] + nums[l] +nums[r]</span><br><span class="line">                if abs(res - target) &gt; abs(temp-target):</span><br><span class="line">                    res = temp</span><br><span class="line">                elif target &lt; temp:</span><br><span class="line">                    r -=1</span><br><span class="line">                else :</span><br><span class="line">                    l +=1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-015-3Sum</title>
      <link href="/2019/02/01/leetcode-015-3Sum/"/>
      <url>/2019/02/01/leetcode-015-3Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-015-3Sum-三数之和"><a href="#leetcode-015-3Sum-三数之和" class="headerlink" title="leetcode-015-3Sum 三数之和"></a>leetcode-015-3Sum 三数之和</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums.sort()</span><br><span class="line">        count = len(nums)</span><br><span class="line">        collect = []</span><br><span class="line">        for i in range(count):</span><br><span class="line">            left = i+1</span><br><span class="line">            right = count-1</span><br><span class="line">            if i &gt;0 and nums[i] == nums[i-1]:</span><br><span class="line">                left +=1</span><br><span class="line">                continue</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                if sum == 0:</span><br><span class="line">                    col = [nums[i],nums[left],nums[right]]</span><br><span class="line">                    collect.append(col)</span><br><span class="line">                    left+=1</span><br><span class="line">                    right-=1</span><br><span class="line">                    while nums[left] == nums[left-1] and left &lt; right:</span><br><span class="line">                        left+=1</span><br><span class="line">                    while nums[right] == nums[right+1] and left &lt; right:</span><br><span class="line">                        right-=1</span><br><span class="line">                if sum&lt;0:</span><br><span class="line">                    left+=1</span><br><span class="line">                elif sum &gt; 0:</span><br><span class="line">                    right-=1</span><br><span class="line">        return collect</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-014-Longest-Common-Prefix</title>
      <link href="/2019/01/31/leetcode-014-Longest-Common-Prefix/"/>
      <url>/2019/01/31/leetcode-014-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-014-Longest-Common-Prefix-最长公共前缀"><a href="#leetcode-014-Longest-Common-Prefix-最长公共前缀" class="headerlink" title="leetcode-014-Longest-Common-Prefix 最长公共前缀"></a>leetcode-014-Longest-Common-Prefix 最长公共前缀</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if strs is None or len(strs) == 0:</span><br><span class="line">            return &apos;&apos;</span><br><span class="line">        res = strs[0]</span><br><span class="line">        for i in range(1, len(strs)):</span><br><span class="line">            tmp = res</span><br><span class="line">            res = &apos;&apos;</span><br><span class="line">            for j in range(min(len(strs[i]),len(tmp))):</span><br><span class="line">                if tmp[j] == strs[i][j]:</span><br><span class="line">                    res += tmp[j]</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-008-String-to-Integer</title>
      <link href="/2019/01/30/leetcode-008-String-to-Integer/"/>
      <url>/2019/01/30/leetcode-008-String-to-Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-008-String-to-Integer-字符串转换整数"><a href="#leetcode-008-String-to-Integer-字符串转换整数" class="headerlink" title="leetcode-008-String-to-Integer 字符串转换整数"></a>leetcode-008-String-to-Integer 字符串转换整数</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [?231,  231 ? 1]。如果数值超过这个范围，qing返回  INT_MAX (231 ? 1) 或 INT_MIN (?231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (-231) 。</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        str = str.strip()</span><br><span class="line">        symbol = 1</span><br><span class="line">        index = 0</span><br><span class="line">        res = 0</span><br><span class="line">        if len(str) == 0:</span><br><span class="line">            return 0</span><br><span class="line">        if str[0] == &apos;-&apos;:</span><br><span class="line">            symbol = -1</span><br><span class="line">            str = str[1:]</span><br><span class="line">        elif str[0] == &apos;+&apos;:</span><br><span class="line">            str = str[1:]</span><br><span class="line">        if len(str) == 0:</span><br><span class="line">            return 0</span><br><span class="line">        while str[index].isnumeric():</span><br><span class="line">            res = res * 10 + int(str[index])</span><br><span class="line">            index += 1</span><br><span class="line">            if index &gt;= len(str):</span><br><span class="line">                break</span><br><span class="line">        res = res * symbol</span><br><span class="line">        if res &gt; 2147483647:</span><br><span class="line">            res =  2147483647</span><br><span class="line">        elif res &lt; -2147483648:</span><br><span class="line">            res = -2147483648</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-005-Longest-Palindromic-Substring</title>
      <link href="/2019/01/29/leetcode-005-Longest-Palindromic-Substring/"/>
      <url>/2019/01/29/leetcode-005-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-005-Longest-Palindromic-Substring-最长回文字串"><a href="#leetcode-005-Longest-Palindromic-Substring-最长回文字串" class="headerlink" title="leetcode-005-Longest-Palindromic-Substring 最长回文字串"></a>leetcode-005-Longest-Palindromic-Substring 最长回文字串</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><p>动态规划：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        max_length = 0</span><br><span class="line">        start = 0</span><br><span class="line">        for i in range(str_length):</span><br><span class="line">            if i - max_length &gt;= 1 and s[i-max_length-1: i+1] == s[i-max_length-1: i+1][::-1]:</span><br><span class="line">                start = i - max_length - 1</span><br><span class="line">                max_length += 2</span><br><span class="line">                continue</span><br><span class="line">            if i - max_length &gt;= 0 and s[i-max_length: i+1] == s[i-max_length: i+1][::-1]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                max_length += 1</span><br><span class="line">        return s[start: start + max_length]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-004-Median_of_Two_Sorted_Arrays</title>
      <link href="/2019/01/28/leetcode-004-Median-of-Two-Sorted-Arrays/"/>
      <url>/2019/01/28/leetcode-004-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-004-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数"><a href="#leetcode-004-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数" class="headerlink" title="leetcode-004-Median-of-Two-Sorted-Arrays 寻找两个有序数组的中位数"></a>leetcode-004-Median-of-Two-Sorted-Arrays 寻找两个有序数组的中位数</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0</p><p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5</p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><p>暴力解法：把两个有序数组排序为一个有序数组，判断数组长度是奇数还是偶数， 然后返回中位数。这种解法的时间复杂度是O(m+n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, nums1, nums2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums1: List[int]</span><br><span class="line">        :type nums2: List[int]</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums = []</span><br><span class="line">        i,j = 0,0</span><br><span class="line">        for k in range(len(nums1) + len(nums2)):</span><br><span class="line">            if (i &lt; len(nums1)) &amp; (j &lt; len(nums2)):</span><br><span class="line">                if nums1[i] &lt; nums2[j]:</span><br><span class="line">                    nums.append(nums1[i])</span><br><span class="line">                    i += 1</span><br><span class="line">                else:</span><br><span class="line">                    nums.append(nums2[j])</span><br><span class="line">                    j += 1</span><br><span class="line">            elif i &lt; len(nums1):</span><br><span class="line">                nums.append(nums1[i])</span><br><span class="line">                i += 1</span><br><span class="line">            elif j &lt; len(nums2):</span><br><span class="line">                nums.append(nums2[j])</span><br><span class="line">                j += 1</span><br><span class="line">        if(len(nums)%2):</span><br><span class="line">            return float(nums[len(nums)//2])</span><br><span class="line">        else:</span><br><span class="line">            return (nums[len(nums)//2 - 1] + nums[len(nums)//2])/float(2)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_001_towsum</title>
      <link href="/2019/01/26/leetcode-001-towsum/"/>
      <url>/2019/01/26/leetcode-001-towsum/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-001-towsum-两数之和"><a href="#leetcode-001-towsum-两数之和" class="headerlink" title="leetcode-001-towsum 两数之和"></a>leetcode-001-towsum 两数之和</h1><hr><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><h2 id="2-解"><a href="#2-解" class="headerlink" title="2. 解"></a>2. 解</h2><ul><li>首先想到用两个for循环，依次相加，判断等于target时返回index。但是这种方法存在重复计算的问题。这种思路是找A + B = target中的A和B两个数。</li></ul><hr><h4 id="换一种思路，从找两个数（A和B）转换为找一个数（B）："><a href="#换一种思路，从找两个数（A和B）转换为找一个数（B）：" class="headerlink" title="换一种思路，从找两个数（A和B）转换为找一个数（B）："></a>换一种思路，从找两个数（A和B）转换为找一个数（B）：</h4><hr><ul><li>用一个for循环遍历数组中的元素，拿到A，那么B肯定也在数组中，并且target - A = B。此时给一个字典，key存target - A也就是B，value存index（这个index是A的）。在字典中找B。这样计算结果就保存在字典中，只需要计算一次即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在遍历数组的过程中：</span><br><span class="line"></span><br><span class="line">如果当前元素（A）不在字典中：kay存target - A（即B），value存A的index；</span><br><span class="line"></span><br><span class="line">如果当前元素在字典中：那么就找到了B，返回当前元素（B）的index和字典中key为B的value，这个value是A的index。</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dict_diff = &#123;&#125;</span><br><span class="line">        for index in range(len(nums)):</span><br><span class="line">            if nums[index] in dict_diff:</span><br><span class="line">                return [dict_diff[nums[index]], index]</span><br><span class="line">            else:</span><br><span class="line">                dict_diff[target - nums[index]] = index</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
