<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-703-Kth-Largest-Element-in-a-Stream]]></title>
    <url>%2F2019%2F02%2F21%2Fleetcode-703-Kth-Largest-Element-in-a-Stream%2F</url>
    <content type="text"><![CDATA[1. 题目设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。 你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。 示例: int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8说明:你可以假设 nums 的长度≥ k-1 且k ≥ 1。 2. 解优先队列，即堆1234567891011121314151617181920212223242526272829303132333435class KthLargest(object): def __init__(self, k, nums): &quot;&quot;&quot; :type k: int :type nums: List[int] &quot;&quot;&quot; self.k = k self.nums = nums # 将nums(list)就地转换为heap对象 heapq.heapify(self.nums) # 如果nums长度大于k，则只保留K个结点的堆，根节点就是第K个大的值 while len(self.nums) &gt; self.k: heapq.heappop(self.nums) def add(self, val): &quot;&quot;&quot; :type val: int :rtype: int &quot;&quot;&quot; # 如果nums长度小于k，则将val压入堆中 if self.k &gt; len(self.nums): heapq.heappush(self.nums,val) # 否则nums长度大于k时，先将val压入堆，排序好之后，pop根节点 else: heapq.heappushpop(self.nums,val) return self.nums[0] # Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 这里用到了堆数据结构（Heap）1234567891011# 将已知的 list 转化为 heap 对象，默认为小顶堆heapq.heapify(list)# 将 item 压入 heapheapq.heappush(heap,item)# 弹出 heap 中最小的值，即为树的根节点heapq.heappop(heap)# 将 item 压入 heap，弹出最小值，并重新排序堆结构heapq.heappushpop(item)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-020-Valid-Parentheses]]></title>
    <url>%2F2019%2F02%2F21%2Fleetcode-020-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[1. 题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 2. 解123456789101112131415161718192021222324class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; stack = [] # 这里用字典的设计很巧妙 paren_map = &#123;&apos;)&apos;:&apos;(&apos;, &apos;]&apos;:&apos;[&apos;, &apos;&#125;&apos;:&apos;&#123;&apos;&#125; for c in s: # 如果不是右括号（是左括号），则此括号入栈 if c not in paren_map: stack.append(c) # 来到这里说明是右括号，这时有两种情况： # 1.栈空：此右括号之前的字符串都可以匹配，此时栈空，右括号入栈，false # 2.栈不空：此右括号与栈顶的左括号不匹配 elif not stack or paren_map[c] != stack.pop(): return False # 如果遍历结束，字符串末端有多余的左括号，没有右括号与之匹配 # 此时栈中存的都是左括号，false return not stack]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-025-Reverse-Nodes-in-k-Group]]></title>
    <url>%2F2019%2F02%2F11%2Fleetcode-025-Reverse-Nodes-in-k-Group%2F</url>
    <content type="text"><![CDATA[1. 题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 :给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 :你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 2. 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseKGroup(self, head, k): &quot;&quot;&quot; :type head: ListNode :type k: int :rtype: ListNode &quot;&quot;&quot; # k=1时为原链表 if k == 1: return head # c遍历链表，为当前结点 c = head # 用tot算出总节点数，知道什么时候该停止 tot = 0 p = head while p: p = p.next tot += 1 # cnt表示目前为止一共reverse了几个节点 cnt = 0 #从头部开始遍历 while c: #判断翻转K个是否越界 if cnt + k &lt;= tot: #分情况讨论，如果是第一次reverse，那么直接返回原始链表的head if cnt == 0: # 这里需要注意的是，第一次反转，记得使用原始链表的头结点head head = self.reverse(c,k) cnt += k else: # 如果不是第一次反转 # 这里有个巧妙的地方，当我们进行完第一次后，c指向第一个reverse区间的最后一个节点 # 所以需要反转c.next为头的子链表 # 这里用临时的头结点head_k替代c遍历链表 head_k = c.next # 用临时的新头结点指向反转好的子链表 new_head = self.reverse(head_k,k) cnt += k # 将之前的链表和反转好的子链表接起来 c.next = new_head # 反转结束后，临时的头结点head_k指向子链表的末尾，重置c的位置 c = head_k #越界就说明我们已经reverse了能reverse的部分，直接退出 else: break return head # 206反转链表（代码思路一模一样）# 需要注意的是，N个结点的需要反转N-1次 def reverse(self,head_k,k): #记录目前reverse的数量 count = 1 new_head = head_k while count &lt; k: t = head_k.next head_k.next = head_k.next.next t.next = new_head new_head = t count += 1 return new_head]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked-List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-141-Linked-List-Cycle]]></title>
    <url>%2F2019%2F02%2F11%2Fleetcode-141-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[leetcode-141-Linked-List-Cycle 环形链表 环形链表两个点： 循环次数 = 环的长度：快慢指针一直到相遇时的循环次数等于环的长度 相遇点到环入口点的距离 = 链表起始点到环入口点的距离 1. 题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 2. 解快慢指针。参考这里1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; fast = head slow = head while fast and slow and fast.next: slow = slow.next fast = fast.next.next if fast is slow: return True return False 1. 题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 2. 解1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; fast = slow = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if fast is slow: new_head = head while new_head is not slow: new_head = new_head.next slow = slow.next return new_head return None]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked-List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-024-Swap-Nodes-in-Pairs]]></title>
    <url>%2F2019%2F02%2F10%2Fleetcode-024-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[leetcode-024-Swap-Nodes-in-Pairs 两两交换链表中的节点 1. 题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 2.解四个需要注意的点吧： 给三个指针，分别指向两个待交换结点和他们的前驱结点 链表的两个特殊情况：[] and [1] 链表的两两交换结点操作 重置三个指针的位置12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; # 开一个常数空间的头结点 new_head = ListNode(-1) # pre始终指向待交换结点的前驱结点 pre = new_head first = head # 两种特殊情况：[] and [1] if head == None or head.next == None: return head else: second = head.next while second: # 两两交换结点的经典操作 pre.next = second first.next = second.next second.next = first # 重置三个结点 pre = first first = pre.next second = pre.next.next if first else None return new_head.next]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked-List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-206-Reverse-Linked-List]]></title>
    <url>%2F2019%2F02%2F03%2Fleetcode-206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[leetcode-206-Reverse-Linked-List 反转链表 1. 题目反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 2. 解2.1 方法一：借用栈结构反转借用Python中list中的insert()函数实现栈结构，用栈来反转。需要注意的是：整个过程中，不动head结点，新初始化一个结点p来遍历链表。12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; p = head newList = [] while p: newList.insert(0,p.val) p = p.next p = head for x in newList: p.val = x p = p.next return head 2.2 方法二：迭代反转其实就是头插法。 2.2.1 头插法一：在链表中反转（head的后继结点插入链表头）head遍历链表。t为head的后继结点，反转操作主要是：head指向head.next.next（即为t.next，把t摘下来），t插入链表头（t.next = new_head），重置头结点（new_head = t）1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None: return head # new_head保存链表头，head遍历链表 new_head = head while head.next is not None: t = head.next head.next = head.next.next t.next = new_head new_head = t return new_head 2.2.2 头插法二：链表拆分为两条（head的前序结点插入链表头）head遍历链表，p为head的前序结点，反转操作主要是：将前序结点p直接插在新链表new_head之前（p.next = new_head），重新将new_head指向头结点（new_head = p）。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; new_head = None while head: # 前序结点 p = head # 当前结点 head = head.next # 将前序结点插入新链表new_head之前 p.next = new_head # 新链表头指针归位 new_head = p return new_head 2.3 方法三：递归123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if not head or not head.next: return head p = head.next n = self.reverseList(p) head.next = None p.next = head return n]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked-List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-016-3Sum-Closest]]></title>
    <url>%2F2019%2F02%2F01%2Fleetcode-016-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[leetcode-016-3Sum-Closest 最接近的三数之和 1. 题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 2. 解12345678910111213141516171819202122class Solution: def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() res = sum(nums[:3]) m = abs(res - target) for i in range(len(nums)): l = i+1 r = len(nums)-1 while l &lt; r: temp = nums[i] + nums[l] +nums[r] if abs(res - target) &gt; abs(temp-target): res = temp elif target &lt; temp: r -=1 else : l +=1 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-015-3Sum]]></title>
    <url>%2F2019%2F02%2F01%2Fleetcode-015-3Sum%2F</url>
    <content type="text"><![CDATA[leetcode-015-3Sum 三数之和 1. 题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2. 解12345678910111213141516171819202122232425262728293031class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() count = len(nums) collect = [] for i in range(count): left = i+1 right = count-1 if i &gt;0 and nums[i] == nums[i-1]: left +=1 continue while left &lt; right: sum = nums[i] + nums[left] + nums[right] if sum == 0: col = [nums[i],nums[left],nums[right]] collect.append(col) left+=1 right-=1 while nums[left] == nums[left-1] and left &lt; right: left+=1 while nums[right] == nums[right+1] and left &lt; right: right-=1 if sum&lt;0: left+=1 elif sum &gt; 0: right-=1 return collect]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-014-Longest-Common-Prefix]]></title>
    <url>%2F2019%2F01%2F31%2Fleetcode-014-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[leetcode-014-Longest-Common-Prefix 最长公共前缀 1. 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 2. 解123456789101112131415161718class Solution: def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if strs is None or len(strs) == 0: return &apos;&apos; res = strs[0] for i in range(1, len(strs)): tmp = res res = &apos;&apos; for j in range(min(len(strs[i]),len(tmp))): if tmp[j] == strs[i][j]: res += tmp[j] else: break return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-008-String-to-Integer]]></title>
    <url>%2F2019%2F01%2F30%2Fleetcode-008-String-to-Integer%2F</url>
    <content type="text"><![CDATA[leetcode-008-String-to-Integer 字符串转换整数 1. 题目请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [?231, 231 ? 1]。如果数值超过这个范围，qing返回 INT_MAX (231 ? 1) 或 INT_MIN (?231) 。 示例 1: 输入: “42”输出: 42示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (-231) 。 2. 解12345678910111213141516171819202122232425262728293031class Solution: def myAtoi(self, str): &quot;&quot;&quot; :type str: str :rtype: int &quot;&quot;&quot; str = str.strip() symbol = 1 index = 0 res = 0 if len(str) == 0: return 0 if str[0] == &apos;-&apos;: symbol = -1 str = str[1:] elif str[0] == &apos;+&apos;: str = str[1:] if len(str) == 0: return 0 while str[index].isnumeric(): res = res * 10 + int(str[index]) index += 1 if index &gt;= len(str): break res = res * symbol if res &gt; 2147483647: res = 2147483647 elif res &lt; -2147483648: res = -2147483648 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-005-Longest-Palindromic-Substring]]></title>
    <url>%2F2019%2F01%2F29%2Fleetcode-005-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[leetcode-005-Longest-Palindromic-Substring 最长回文字串 1. 题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 2. 解动态规划：12345678910111213141516171819class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; str_length = len(s) max_length = 0 start = 0 for i in range(str_length): if i - max_length &gt;= 1 and s[i-max_length-1: i+1] == s[i-max_length-1: i+1][::-1]: start = i - max_length - 1 max_length += 2 continue if i - max_length &gt;= 0 and s[i-max_length: i+1] == s[i-max_length: i+1][::-1]: start = i - max_length max_length += 1 return s[start: start + max_length]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-004-Median_of_Two_Sorted_Arrays]]></title>
    <url>%2F2019%2F01%2F28%2Fleetcode-004-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[leetcode-004-Median-of-Two-Sorted-Arrays 寻找两个有序数组的中位数 1. 题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 2. 解暴力解法：把两个有序数组排序为一个有序数组，判断数组长度是奇数还是偶数， 然后返回中位数。这种解法的时间复杂度是O(m+n)123456789101112131415161718192021222324252627class Solution: def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; nums = [] i,j = 0,0 for k in range(len(nums1) + len(nums2)): if (i &lt; len(nums1)) &amp; (j &lt; len(nums2)): if nums1[i] &lt; nums2[j]: nums.append(nums1[i]) i += 1 else: nums.append(nums2[j]) j += 1 elif i &lt; len(nums1): nums.append(nums1[i]) i += 1 elif j &lt; len(nums2): nums.append(nums2[j]) j += 1 if(len(nums)%2): return float(nums[len(nums)//2]) else: return (nums[len(nums)//2 - 1] + nums[len(nums)//2])/float(2)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_001_towsum]]></title>
    <url>%2F2019%2F01%2F26%2Fleetcode-001-towsum%2F</url>
    <content type="text"><![CDATA[leetcode-001-towsum 两数之和 1. 题目给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 2. 解 首先想到用两个for循环，依次相加，判断等于target时返回index。但是这种方法存在重复计算的问题。这种思路是找A + B = target中的A和B两个数。 换一种思路，从找两个数（A和B）转换为找一个数（B）： 用一个for循环遍历数组中的元素，拿到A，那么B肯定也在数组中，并且target - A = B。此时给一个字典，key存target - A也就是B，value存index（这个index是A的）。在字典中找B。这样计算结果就保存在字典中，只需要计算一次即可。12345678910111213141516171819在遍历数组的过程中：如果当前元素（A）不在字典中：kay存target - A（即B），value存A的index；如果当前元素在字典中：那么就找到了B，返回当前元素（B）的index和字典中key为B的value，这个value是A的index。class Solution: def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict_diff = &#123;&#125; for index in range(len(nums)): if nums[index] in dict_diff: return [dict_diff[nums[index]], index] else: dict_diff[target - nums[index]] = index]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
